First look, I noticed that we need to check the primality of three massive binary numbers. Initially, I considered using Fermat's Little Theoremâ€”after all, the book tells us that if p is prime and a is not divisible by p, then a^(p-1) = 1 mod p. However, the problem with relying solely on Fermat's test is not that raising a to a huge power is computationally intensive -- it is that Fermat's theorem can yield false positives. Some composite numbers, known as Carmichael numbers, also satisfy a^(p-1) = 1 mod p for many choices of a, making them look prime when they are not.
To address this issue, I based my algorithm on the Miller-Rabin test. The Miller-Rabin test refines Fermat's approach by first expressing p-1 as 2^r * d, where d is odd. Instead of checking a^(p-1) = 1 mod p directly, it computes a^d mod p and then repeatedly squares that result. For a prime p, either a^d = 1 mod p or one of the successive squares will yield -1 mod p. This extra layer of checking helps catch false positives that a simple Fermat test might miss.
Looking at the inputs, I noticed that each binary number has a "0b" prefix. That meant I needed a function to read the files and return just the binary digits, excluding the "0b". I used Python's "re" library to parse the file and extract everything after "0b". So the first hurdle was overcome.
Next, I had to convert the binary string to a decimal number. After digging through my Python notes, I learned that Python's built-in conversion using int(binary_string, 2) makes this trivial. This saved me from writing a function that would manually calculate powers of 2 for each bit.
Because these binary numbers are massive, testing them sequentially would take too long. To optimize the process, I implemented multithreading so that all three numbers are tested concurrently using the Miller-Rabin test. Each thread runs up to 100 iterations of the test on its assigned number. If a thread finds a composite witness, it stops immediately. Furthermore, if two threads have already determined that their numbers are composite, the remaining thread stops early and assumes its number is prime -- since we know that only one of the three numbers is prime.
In summary, the algorithm works as follows:
File Parsing: Read each file, remove the "0b" prefix using a regular expression, and extract the binary digits.
Conversion: Convert the binary string to a decimal integer with Python's int(binary_string, 2).
Primality Testing: Apply the Miller-Rabin test concurrently in three separate threads. Each thread performs up to 100 iterations:
If a composite witness is found in a thread, that thread stops and marks its number as "Composite".
If two threads are marked "Composite," the remaining thread halts early and assumes its number is "Prime".
Output: Write the final results ("Prime" or "Composite" for each input) to results.txt.
This approach, which combines the reliability of the Miller-Rabin test with the efficiency of multithreading and early termination, ensures that we accurately and swiftly determine the primality of these massive binary numbers
